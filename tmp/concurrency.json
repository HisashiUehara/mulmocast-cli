{
    "$mulmocast": {
      "version": "1.0",
      "credit": "closing"
    },
    "canvasSize": {
      "width": 1536,
      "height": 1024
    },
    "speechParams": {
      "provider": "openai",
      "speakers": {
        "Presenter": {
          "displayName": {
            "en": "Presenter",
            "ja": "語り手"
          },
          "voiceId": "shimmer"
        }
      }
    },
    "imageParams": {
      "style": "Style appropriate for software presentation.",
      "provider": "openai"
    },
    "title": "Mastering Concurrent Programming in TypeScript",
    "lang": "en",
    "beats": [
      {
        "speaker": "Presenter",
        "text": "Welcome everyone to our deep dive into concurrent programming with TypeScript. Today we'll explore how to write effective asynchronous code, understand the underlying model, and avoid common pitfalls that can lead to bugs and performance issues.",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "Mastering Concurrent Programming in TypeScript",
            "bullets": []
          }
        },
        "textSlideParams": {
          "cssStyles": ["h1 { margin-top: 400px }"]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Before we start, let's clarify what we mean by concurrent programming in TypeScript. Unlike languages with true multithreading capabilities, TypeScript inherits JavaScript's single-threaded execution model with an event loop for handling asynchronous operations. Understanding this foundation is crucial.",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "What is Concurrent Programming in TypeScript?",
            "bullets": [
              "Single-threaded execution model",
              "Event-driven architecture",
              "Non-blocking I/O operations",
              "Asynchronous programming patterns"
            ]
          }
        }
      },
      {
        "speaker": "Presenter",
        "text": "The core of TypeScript's concurrency model is the event loop. It's essential to understand how this works. The event loop continuously checks for tasks in the queue and executes them in order. When an asynchronous operation is encountered, it's offloaded, allowing the main thread to continue processing other tasks.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# The Event Loop",
            "",
            "```ascii",
            "  ┌───────────────────────────┐",
            "  │        Call Stack         │",
            "  └───────────────┬───────────┘",
            "                  │",
            "                  ▼",
            "  ┌───────────────────────────┐",
            "  │        Event Loop         │",
            "  └───────────────┬───────────┘",
            "                  │",
            "                  ▼",
            "  ┌───────────────────────────┐",
            "  │        Task Queue         │",
            "  └───────────────────────────┘",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Let's start with the building blocks of async programming in TypeScript: Promises. A Promise represents a value that might not be available yet but will be resolved at some point in the future. This is the foundation of async operations in TypeScript.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Promises in TypeScript",
            "",
            "```typescript",
            "// Creating a Promise",
            "const fetchUserData = (userId: string): Promise<User> => {",
            "  return new Promise((resolve, reject) => {",
            "    // Async operation (e.g., API call)",
            "    api.getUser(userId)",
            "      .then(user => resolve(user))",
            "      .catch(error => reject(error));",
            "  });",
            "};",
            "",
            "// Using a Promise",
            "fetchUserData('user123')",
            "  .then(user => console.log(user.name))",
            "  .catch(error => console.error('Failed to fetch user:', error));",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "While Promises are powerful, they can lead to complex chains that are difficult to read and maintain. This is where async and await come in. These keywords provide a more synchronous-looking way to write asynchronous code, making it easier to understand the flow of execution.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Async/Await Syntax",
            "",
            "```typescript",
            "// Using async/await",
            "async function getUserDetails(userId: string): Promise<UserDetails> {",
            "  try {",
            "    // Each await pauses execution until the Promise resolves",
            "    const user = await fetchUserData(userId);",
            "    const posts = await fetchUserPosts(user.id);",
            "    const followers = await fetchUserFollowers(user.id);",
            "",
            "    return {",
            "      user,",
            "      posts,",
            "      followers",
            "    };",
            "  } catch (error) {",
            "    console.error('Error fetching user details:', error);",
            "    throw error;",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "One of the key benefits of TypeScript is its type system, which provides safety and better tooling for asynchronous code. Let's see how to leverage TypeScript's type system for concurrent programming.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# TypeScript Types for Async Code",
            "",
            "```typescript",
            "// Defining types for async operations",
            "interface User {",
            "  id: string;",
            "  name: string;",
            "  email: string;",
            "}",
            "",
            "interface AsyncResult<T> {",
            "  status: 'pending' | 'fulfilled' | 'rejected';",
            "  data?: T;",
            "  error?: Error;",
            "}",
            "",
            "// Type-safe async function",
            "async function fetchUser(id: string): Promise<AsyncResult<User>> {",
            "  try {",
            "    const user = await api.getUser(id);",
            "    return { status: 'fulfilled', data: user };",
            "  } catch (error) {",
            "    return { ",
            "      status: 'rejected', ",
            "      error: error instanceof Error ? error : new Error(String(error))",
            "    };",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Now let's look at how to execute multiple asynchronous operations in parallel. Promise.all allows us to run multiple Promises concurrently and wait for all of them to complete before continuing.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Parallel Execution with Promise.all",
            "",
            "```typescript",
            "// Fetching multiple resources in parallel",
            "async function fetchDashboardData(userId: string): Promise<DashboardData> {",
            "  // All three requests start at the same time",
            "  const [user, posts, notifications] = await Promise.all([",
            "    fetchUserData(userId),",
            "    fetchUserPosts(userId),",
            "    fetchUserNotifications(userId)",
            "  ]);",
            "",
            "  return {",
            "    user,",
            "    posts,",
            "    notifications",
            "  };",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "While Promise.all is useful, it has one major drawback: if any of the Promises reject, the entire operation fails. When you need more flexibility, you can use Promise.allSettled, which waits for all Promises to complete regardless of whether they succeed or fail.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Handling Multiple Outcomes with Promise.allSettled",
            "",
            "```typescript",
            "async function fetchResourcesWithFallbacks(): Promise<Resources> {",
            "  const results = await Promise.allSettled([",
            "    fetchPrimaryData(),",
            "    fetchSecondaryData(),",
            "    fetchTertiaryData()",
            "  ]);",
            "",
            "  // Process results individually",
            "  return results.map((result, index) => {",
            "    if (result.status === 'fulfilled') {",
            "      return result.value;",
            "    } else {",
            "      console.warn(`Resource ${index} failed:`, result.reason);",
            "      return getDefaultData(index);",
            "    }",
            "  });",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Now let's talk about one of the most common pitfalls in concurrent programming: race conditions. These occur when the outcome of an operation depends on the timing or sequence of events that cannot be guaranteed.",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "Common Pitfall: Race Conditions",
            "bullets": [
              "Occur when operation outcomes depend on unpredictable event timing",
              "Shared mutable state is often the culprit",
              "Difficult to debug due to sporadic nature",
              "Can lead to data corruption and unpredictable behavior"
            ]
          }
        }
      },
      {
        "speaker": "Presenter",
        "text": "Here's an example of a race condition in TypeScript, along with a solution. In this code, multiple asynchronous operations are trying to update a shared counter, which can lead to inconsistent results.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Race Condition Example and Solution",
            "",
            "```typescript",
            "// Problematic code with race condition",
            "let counter = 0;",
            "",
            "async function incrementLater() {",
            "  const current = counter;",
            "  // Simulating async delay",
            "  await new Promise(resolve => setTimeout(resolve, Math.random() * 100));",
            "  counter = current + 1; // Race condition here!",
            "}",
            "",
            "// Solution: Using synchronization",
            "class SafeCounter {",
            "  private value = 0;",
            "  private mutex = Promise.resolve();",
            "",
            "  async increment(): Promise<number> {",
            "    return this.mutex = this.mutex.then(async () => {",
            "      this.value += 1;",
            "      return this.value;",
            "    });",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Another common pitfall is the callback hell, which can make code difficult to read and maintain. This is especially important to avoid in large applications where clarity is essential.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Avoiding Callback Hell",
            "",
            "```typescript",
            "// Before: Callback Hell",
            "fetchUserData(userId, (userData) => {",
            "  processUserData(userData, (processedData) => {",
            "    saveUserPreferences(processedData, (result) => {",
            "      notifyUser(result, () => {",
            "        updateUI(userData);",
            "      }, handleError);",
            "    }, handleError);",
            "  }, handleError);",
            "}, handleError);",
            "",
            "// After: Using async/await",
            "async function userWorkflow(userId: string): Promise<void> {",
            "  try {",
            "    const userData = await fetchUserData(userId);",
            "    const processedData = await processUserData(userData);",
            "    const result = await saveUserPreferences(processedData);",
            "    await notifyUser(result);",
            "    updateUI(userData);",
            "  } catch (error) {",
            "    handleError(error);",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Error handling is critical in asynchronous code. Unhandled promise rejections can lead to silent failures and are difficult to debug. Let's look at proper error handling patterns in TypeScript.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Proper Error Handling",
            "",
            "```typescript",
            "// Using try/catch with async/await",
            "async function robustOperation(): Promise<Result> {",
            "  try {",
            "    const data = await fetchData();",
            "    return processData(data);",
            "  } catch (error) {",
            "    // Log detailed error information",
            "    logger.error('Operation failed:', {",
            "      error: error instanceof Error ? error.message : String(error),",
            "      stack: error instanceof Error ? error.stack : undefined,",
            "      timestamp: new Date().toISOString()",
            "    });",
            "",
            "    // Provide fallback or rethrow with context",
            "    if (isFallbackAvailable()) {",
            "      return getFallbackData();",
            "    }",
            "    throw new OperationError('Processing failed', { cause: error });",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Cancellation is often overlooked but is essential for resource management and responsiveness. TypeScript now supports the AbortController API, which provides a standard way to cancel asynchronous operations.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Implementing Cancellation",
            "",
            "```typescript",
            "// Cancellable fetch operation",
            "async function fetchWithTimeout(url: string, timeoutMs: number): Promise<Response> {",
            "  const controller = new AbortController();",
            "  const { signal } = controller;",
            "",
            "  // Set up timeout to cancel the request",
            "  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);",
            "",
            "  try {",
            "    const response = await fetch(url, { signal });",
            "    clearTimeout(timeoutId);",
            "    return response;",
            "  } catch (error) {",
            "    clearTimeout(timeoutId);",
            "    ",
            "    if (error.name === 'AbortError') {",
            "      throw new Error(`Request timed out after ${timeoutMs}ms`);",
            "    }",
            "    throw error;",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Blocking the main thread is a serious performance issue that can make your application unresponsive. Let's look at how to handle CPU-intensive tasks without affecting the user experience.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Avoiding Main Thread Blocking",
            "",
            "```typescript",
            "// Processing large datasets in chunks",
            "async function processLargeArray<T, R>(",
            "  items: T[],",
            "  processFn: (item: T) => Promise<R>,",
            "  chunkSize = 5",
            "): Promise<R[]> {",
            "  const results: R[] = [];",
            "  ",
            "  for (let i = 0; i < items.length; i += chunkSize) {",
            "    // Process a chunk of items",
            "    const chunk = items.slice(i, i + chunkSize);",
            "    const chunkResults = await Promise.all(chunk.map(processFn));",
            "    results.push(...chunkResults);",
            "    ",
            "    // Yield to the event loop",
            "    await new Promise(resolve => setTimeout(resolve, 0));",
            "  }",
            "  ",
            "  return results;",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "For truly CPU-intensive tasks, we can use Web Workers to run code in a separate thread. This keeps the main thread free for user interactions. Let's see how to set this up in TypeScript.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Using Web Workers",
            "",
            "```typescript",
            "// main.ts",
            "const worker = new Worker('worker.js');",
            "",
            "// Type-safe worker communication",
            "type WorkerRequest = {",
            "  id: string;",
            "  action: 'PROCESS_DATA';",
            "  payload: any;",
            "};",
            "",
            "type WorkerResponse = {",
            "  id: string;",
            "  result: any;",
            "  error?: string;",
            "};",
            "",
            "// Send message to worker",
            "function sendToWorker(action: WorkerRequest['action'], payload: any): Promise<any> {",
            "  return new Promise((resolve, reject) => {",
            "    const id = Math.random().toString(36).substring(2);",
            "    ",
            "    // Handle response",
            "    worker.addEventListener('message', function handler(event) {",
            "      const response = event.data as WorkerResponse;",
            "      if (response.id === id) {",
            "        worker.removeEventListener('message', handler);",
            "        if (response.error) {",
            "          reject(new Error(response.error));",
            "        } else {",
            "          resolve(response.result);",
            "        }",
            "      }",
            "    });",
            "    ",
            "    // Send request",
            "    worker.postMessage({ id, action, payload });",
            "  });",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Memory leaks are a serious concern in long-running applications. They often occur with forgotten promises, uncleared intervals, or lingering event listeners. Let's look at patterns to prevent these issues.",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "Preventing Memory Leaks",
            "bullets": [
              "Always clean up resources when components unmount",
              "Use AbortController to cancel pending requests",
              "Clear intervals and timeouts",
              "Remove event listeners",
              "Watch for closures holding references to large objects"
            ]
          }
        }
      },
      {
        "speaker": "Presenter",
        "text": "Here's an example showing how to properly manage resources in a typical TypeScript application component lifecycle.",
        "image": {
          "type": "markdown",
          "markdown": [
            "# Resource Cleanup Pattern",
            "",
            "```typescript",
            "// In a React component (but applies to any framework)",
            "class DataFetcher {",
            "  private abortController: AbortController | null = null;",
            "  private pollingInterval: number | null = null;",
            "  private eventSource: EventSource | null = null;",
            "",
            "  async fetchData(url: string): Promise<void> {",
            "    // Cancel any existing requests",
            "    this.cleanup();",
            "    ",
            "    // Create new controller for this request",
            "    this.abortController = new AbortController();",
            "    ",
            "    try {",
            "      const response = await fetch(url, { ",
            "        signal: this.abortController.signal ",
            "      });",
            "      // Process response...",
            "    } catch (error) {",
            "      if (error.name !== 'AbortError') {",
            "        throw error;",
            "      }",
            "    }",
            "  }",
            "",
            "  startPolling(url: string, interval: number): void {",
            "    this.pollingInterval = window.setInterval(() => {",
            "      this.fetchData(url);",
            "    }, interval);",
            "  }",
            "",
            "  listenForEvents(url: string): void {",
            "    this.eventSource = new EventSource(url);",
            "    this.eventSource.addEventListener('message', this.handleEvent);",
            "  }",
            "",
            "  cleanup(): void {",
            "    // Cancel pending fetch requests",
            "    if (this.abortController) {",
            "      this.abortController.abort();",
            "      this.abortController = null;",
            "    }",
            "    ",
            "    // Clear polling interval",
            "    if (this.pollingInterval !== null) {",
            "      clearInterval(this.pollingInterval);",
            "      this.pollingInterval = null;",
            "    }",
            "    ",
            "    // Close event source",
            "    if (this.eventSource) {",
            "      this.eventSource.removeEventListener('message', this.handleEvent);",
            "      this.eventSource.close();",
            "      this.eventSource = null;",
            "    }",
            "  }",
            "}",
            "```"
          ]
        }
      },
      {
        "speaker": "Presenter",
        "text": "Finally, let's look at some best practices for concurrent programming in TypeScript. These guidelines will help you write more maintainable and efficient asynchronous code.",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "Best Practices",
            "bullets": [
              "Prefer async/await over raw Promises for readability",
              "Use TypeScript's type system to make async code safer",
              "Implement proper error handling at every level",
              "Control concurrency to avoid overwhelming resources",
              "Use appropriate Promise combinators (all, allSettled, race, any)",
              "Break large operations into manageable chunks",
              "Implement cancellation for long-running operations",
              "Always clean up resources to prevent memory leaks"
            ]
          }
        }
      },
      {
        "speaker": "Presenter",
        "text": "To summarize what we've covered today: TypeScript provides powerful tools for concurrent programming built on JavaScript's asynchronous model. By understanding the event loop, leveraging TypeScript's type system, and following best practices, you can write concurrent code that is both safe and maintainable.",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "Key Takeaways",
            "bullets": [
              "TypeScript concurrency is based on JavaScript's event loop",
              "Async/await makes asynchronous code readable and maintainable",
              "TypeScript's type system enhances safety for concurrent operations",
              "Avoiding common pitfalls requires understanding and vigilance",
              "Proper resource management prevents memory leaks",
              "Advanced patterns help with complex concurrency scenarios"
            ]
          }
        }
      },
      {
        "speaker": "Presenter",
        "text": "Thank you for attending this presentation on concurrent programming in TypeScript. I hope you found it informative and practical. Are there any questions I can answer?",
        "image": {
          "type": "textSlide",
          "slide": {
            "title": "Thank You!",
            "bullets": [
              "Questions?",
              "Resources:",
              "- TypeScript Documentation",
              "- JavaScript Concurrency Model and Event Loop",
              "- Web Workers API",
              "- Contact: presenter@example.com"
            ]
          }
        },
        "textSlideParams": {
          "cssStyles": ["h1 { margin-top: 350px }"]
        }
      }
    ]
  }